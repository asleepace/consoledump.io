---
import { cn } from '@/lib/utils'
import type { MarkdownHeading } from 'astro'

interface Props {
  headings: MarkdownHeading[]
  className?: string
}

const { headings, className } = Astro.props
---

<aside
  aria-label="Table of contents"
  class={cn('hidden xl:block shrink-0 sticky top-32 self-start', className)}
>
  <nav
    class="toc max-h-[calc(100vh-7rem)] overflow-y-auto border-l border-l-neutral-800 pl-6"
  >
    <ol>
      {
        headings
          .filter((h) => h.depth === 2 || h.depth === 3)
          .map((h) => (
            <li class:list={[h.depth === 3 ? 'depth-3' : 'depth-2']}>
              <a
                data-active="false"
                class="text-neutral-300 data-[active=true]:text-orange-400 px-2"
                href={`#${h.slug}`}
              >
                {h.text}
              </a>
            </li>
          ))
      }
    </ol>
  </nav>
</aside>
<script is:inline>
  // Highlight active section in ToC and keep it in view
  const headingsQuery = 'article h2[id], article h3[id]'
  const headingEls = Array.from(document.querySelectorAll(headingsQuery))
  const links = Array.from(document.querySelectorAll('.toc a'))
  const linkById = new Map(
    links.map((a) => [
      decodeURIComponent((a.getAttribute('href') || '').slice(1)),
      a,
    ])
  )

  let activeId = ''

  function updateActiveLink() {
    const topVisible = headingEls
      .map((el) => ({ id: el.id, top: el.getBoundingClientRect().top }))
      .filter((v) => v.top >= 0 && v.top < window.innerHeight * 0.6)
      .sort((a, b) => a.top - b.top)[0]

    const next = topVisible?.id || activeId
    if (!next || next === activeId) return
    activeId = next

    // Reset classes
    links.forEach((a) => {
      a.setAttribute('data-active', 'false')
    })
    const link = linkById.get(next)
    if (link) {
      link.setAttribute('data-active', 'true')
      const aside = link.closest('aside')
      if (aside) {
        const pr = aside.getBoundingClientRect()
        const lr = link.getBoundingClientRect()
        if (lr.top < pr.top || lr.bottom > pr.bottom) {
          aside.scrollTo({ top: link.offsetTop - 32, behavior: 'smooth' })
        }
      }
    }
  }

  const obs = new IntersectionObserver(updateActiveLink, {
    root: null,
    rootMargin: '-120px 0px -60% 0px',
    threshold: [0],
  })

  headingEls.forEach((el) => obs.observe(el))

  // Initial highlight on page load
  setTimeout(updateActiveLink, 100)
</script>
