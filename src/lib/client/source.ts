console.clear()

const data = `data: {"clientId":"0x56E0","streamId":"273be3","createdAt":"2025-10-22T23:41:49.691Z","updatedAt":"2025-10-23T21:25:51.093Z","clients":9}

id: 0
data: ["[main] error:",{"status":403,"statusText":"Not Authorized","message":"Missing or invalid X-Client-Secret header."}]

id: 1
data: ["[main] error:",{"status":403,"statusText":"Not Authorized","message":"Missing or invalid X-Client-Secret header."}]

id: 2
data: ["[airtable] incoming: ","https://airtable-proxy.val.run/api/ai-generate-async?airtable-callback=https%3A%2F%2Fapi.airtable.com%2Fv0%2FappMbMW3rzbXTlgWq%2FResources%2FrecjJitaQd1WSuKHH"]

id: 3
data: ["[airtable] proxied: ","https://sondheim-proxy.val.run/api/ai-generate-async?airtable-callback=https%3A%2F%2Fapi.airtable.com%2Fv0%2FappMbMW3rzbXTlgWq%2FResources%2FrecjJitaQd1WSuKHH"]

id: 4
data: ["[main] error:",{"status":403,"statusText":"Not Authorized","message":"Missing or invalid X-Client-Secret header."}]

id: 5
data: ["[main] error:",{"status":403,"statusText":"Not Authorized","message":"Missing or invalid X-Client-Secret header."}]

id: 6
data: ["[main] error:",{"status":403,"statusText":"Not Authorized","message":"Missing or invalid X-Client-Secret header."}]

id: 7
data: ["[main] error:",{"status":403,"statusText":"Not Authorized","message":"Missing or invalid X-Client-Secret header."}]

id: 8
data: ["[main] error:",{"status":403,"statusText":"Not Authorized","message":"Missing or invalid X-Client-Secret header."}]

id: 9
data: ["[main] error:",{"status":403,"statusText":"Not Authorized","message":"Missing or invalid X-Client-Secret header."}]

id: 10
data: ["[main] error:",{"status":403,"statusText":"Not Authorized","message":"Missing or invalid X-Client-Secret header."}]

id: 11
data: ["[main] client not authorized!"]

id: 12
data: ["[main] error:",{"status":403,"statusText":"Not Authorized","message":"Missing or invalid X-Client-Secret header."}]

id: 13
data: ["[main] error:",{"status":403,"statusText":"Not Authorized","message":"Missing or invalid X-Client-Secret header."}]

id: 14
data: ["[main] client not authorized!"]

id: 15
data: ["[airtable] proxied: ","https://sondheim-proxy.val.run/api/ai-generate-async?airtable-callback=https%3A%2F%2Fapi.airtable.com%2Fv0%2FappMbMW3rzbXTlgWq%2FResources%2FrecjJitaQd1WSuKHH"]

id: 16
data: ["[airtable] incoming: ","https://airtable-proxy.val.run/api/ai-generate-async?airtable-callback=https%3A%2F%2Fapi.airtable.com%2Fv0%2FappMbMW3rzbXTlgWq%2FResources%2FrecjJitaQd1WSuKHH"]

id: 17
data: ["[main] params:",{"airtable-callback":"https://api.airtable.com/v0/appMbMW3rzbXTlgWq/Resources/recjJitaQd1WSuKHH"}]

id: 18
data: ["[main] resp:",500,"Internal Server Error"]

id: 19
data: ["[main] json:",{"message":"[\n  {\n    \"code\": \"invalid_type\",\n    \"expected\": \"string\",\n    \"received\": \"null\",\n    \"path\": [\n      \"input\",\n      \"details\"\n    ],\n    \"message\": \"Expected string, received null\"\n  }\n]"}]

id: 20
data: ["[api-airtable] callback:","https://api.airtable.com/v0/appMbMW3rzbXTlgWq/Resources/recjJitaQd1WSuKHH"]

id: 21
data: ["[airtable] incoming: ","https://airtable-proxy.val.run/api/ai-generate-async?airtable-callback=https%3A%2F%2Fapi.airtable.com%2Fv0%2FappMbMW3rzbXTlgWq%2FResources%2FrecjJitaQd1WSuKHH"]

id: 22
data: ["[airtable] proxied: ","https://sondheim-proxy.val.run/api/ai-generate-async?airtable-callback=https%3A%2F%2Fapi.airtable.com%2Fv0%2FappMbMW3rzbXTlgWq%2FResources%2FrecjJitaQd1WSuKHH"]

id: 23
data: ["[main] params:",{"airtable-callback":"https://api.airtable.com/v0/appMbMW3rzbXTlgWq/Resources/recjJitaQd1WSuKHH"}]

id: 24
data: ["[main] resp:",200,"OK"]

id: 25
data: ["[main] json:",{"resourceUrl":"https://ta.padlet.com/flashcards/Rej9RGkBpd"}]

id: 26
data: ["[api-airtable] callback:","https://api.airtable.com/v0/appMbMW3rzbXTlgWq/Resources/recjJitaQd1WSuKHH"]

id: 27
data: ["[airtable] proxied: ","https://sondheim-proxy.val.run/api/ai-generate-async?airtable-callback=https%3A%2F%2Fapi.airtable.com%2Fv0%2FappMbMW3rzbXTlgWq%2FResources%2FreckZERusQHR7bvwy"]

id: 28
data: ["[airtable] incoming: ","https://airtable-proxy.val.run/api/ai-generate-async?airtable-callback=https%3A%2F%2Fapi.airtable.com%2Fv0%2FappMbMW3rzbXTlgWq%2FResources%2FreckZERusQHR7bvwy"]

id: 29
data: ["[main] params:",{"airtable-callback":"https://api.airtable.com/v0/appMbMW3rzbXTlgWq/Resources/reckZERusQHR7bvwy"}]

id: 30
data: ["[airtable] proxied: ","https://sondheim-proxy.val.run/api/ai-generate-async?airtable-callback=https%3A%2F%2Fapi.airtable.com%2Fv0%2FappMbMW3rzbXTlgWq%2FResources%2FreckZERusQHR7bvwy"]

id: 31
data: ["[airtable] incoming: ","https://airtable-proxy.val.run/api/ai-generate-async?airtable-callback=https%3A%2F%2Fapi.airtable.com%2Fv0%2FappMbMW3rzbXTlgWq%2FResources%2FreckZERusQHR7bvwy"]

id: 32
data: ["[main] params:",{"airtable-callback":"https://api.airtable.com/v0/appMbMW3rzbXTlgWq/Resources/reckZERusQHR7bvwy"}]

id: 33
data: ["[main] resp:",200,"OK"]

id: 34
data: ["[main] json:",{"resourceUrl":"https://ta.padlet.com/flashcards/v5j1Rl6vpW"}]

id: 35
data: ["[api-airtable] callback:","https://api.airtable.com/v0/appMbMW3rzbXTlgWq/Resources/reckZERusQHR7bvwy"]

id: 36
data: ["[main] resp:",200,"OK"]

id: 37
data: ["[main] json:",{"resourceUrl":"https://ta.padlet.com/flashcards/exjLX9RYjO"}]

id: 38
data: ["[api-airtable] callback:","https://api.airtable.com/v0/appMbMW3rzbXTlgWq/Resources/reckZERusQHR7bvwy"]

id: 39
data: ["[airtable] proxied: ","https://sondheim-proxy.val.run/api/ai-generate-async?airtable-callback=https%3A%2F%2Fapi.airtable.com%2Fv0%2FappMbMW3rzbXTlgWq%2FResources%2FreckZERusQHR7bvwy"]

id: 40
data: ["[airtable] incoming: ","https://airtable-proxy.val.run/api/ai-generate-async?airtable-callback=https%3A%2F%2Fapi.airtable.com%2Fv0%2FappMbMW3rzbXTlgWq%2FResources%2FreckZERusQHR7bvwy"]

id: 41
data: ["[main] params:",{"airtable-callback":"https://api.airtable.com/v0/appMbMW3rzbXTlgWq/Resources/reckZERusQHR7bvwy"}]

id: 42
data: ["[main] resp:",200,"OK"]

id: 43
data: ["[main] json:",{"resourceUrl":"https://ta.padlet.com/flashcards/aBKQRLO1rZ"}]

id: 44
data: ["[api-airtable] callback:","https://api.airtable.com/v0/appMbMW3rzbXTlgWq/Resources/reckZERusQHR7bvwy"]

id: 45
data: ["[main] client not authorized!"]

id: 46
data: ["[main] error:",{"status":403,"statusText":"Not Authorized","message":"Missing or invalid X-Client-Secret header."}]

id: 47
data: ["[main] client not authorized!"]

id: 48
data: ["[main] error:",{"status":403,"statusText":"Not Authorized","message":"Missing or invalid X-Client-Secret header."}]

id: 49
data: ["[airtable] proxied: ","https://sondheim-proxy.val.run/api/ai-generate-async?airtable-callback=https%3A%2F%2Fapi.airtable.com%2Fv0%2FappMbMW3rzbXTlgWq%2FResources%2FreckZERusQHR7bvwy"]

id: 50
data: ["[airtable] incoming: ","https://airtable-proxy.val.run/api/ai-generate-async?airtable-callback=https%3A%2F%2Fapi.airtable.com%2Fv0%2FappMbMW3rzbXTlgWq%2FResources%2FreckZERusQHR7bvwy"]

id: 51
data: ["[main] params:",{"airtable-callback":"https://api.airtable.com/v0/appMbMW3rzbXTlgWq/Resources/reckZERusQHR7bvwy"}]

id: 52
data: ["[main] resp:",200,"OK"]

id: 53
data: ["[main] json:",{"resourceUrl":"https://ta.padlet.com/flashcards/YkK4Rm6vjl"}]

id: 54
data: ["[api-airtable] callback:","https://api.airtable.com/v0/appMbMW3rzbXTlgWq/Resources/reckZERusQHR7bvwy"]

id: 55
data: ["[airtable] proxied: ","https://sondheim-proxy.val.run/"]

id: 56
data: ["[airtable] incoming: ","https://padlet--7f89534e9ff511f0b11d0224a6c84d84.web.val.run/"]

id: 57
data: ["[airtable] proxied: ","https://sondheim-proxy.val.run/"]

id: 58
data: ["[airtable] incoming: ","https://airtable-proxy.val.run/"]

id: 59
data: ["[main] error:",{"status":404,"statusText":"Route Not Defined"}]

id: 60
data: ["[main] error:",{"status":404,"statusText":"Route Not Defined"}]

id: 61
data: ["[main] client not authorized!"]

id: 62
data: ["[main] error:",{"status":403,"statusText":"Not Authorized","message":"Missing or invalid X-Client-Secret header."}]

: keep-alive

id: 63
data: name, age, sex,
colin, 33, male,
katie, 30, female
`

// function* publish(str: string) {
//     let seperator = '\n\n'
//     let buffer = str
//     while (buffer && buffer.length) {
//         const index = buffer.indexOf(seperator)

//         if (index === -1) {
//             yield buffer + seperator
//             buffer = ''
//             break
//         }

//         const j = index + seperator.length
//         const randomSlice = buffer.slice(0, j)
//         yield randomSlice
//         buffer = buffer.slice(j)
//     }
// }

// const test = () => publish(data)

// function* split(incoming: Generator<string>, separator: string) {
//     const len = separator.length
//     let buffer = ''

//     for (const chunk of incoming) {  // ✅ Simpler: use for...of
//         buffer += chunk

//         while (buffer.includes(separator)) {  // ✅ Handle multiple separators in buffer
//             const idx = buffer.indexOf(separator)
//             yield buffer.slice(0, idx)
//             buffer = buffer.slice(idx + len)
//         }
//     }

//     // Yield remaining buffer if not empty
//     if (buffer.trim()) {
//         yield buffer
//     }
// }

// function* map<I, O>(source: Generator<I>, transform: Generator<O, void, I>) {
//     return yield* source.map((item) => transform.next(item).value)
// }

// function chunkBy(seperator: string) {
//     console.log('creating...')
//     let buffer: string = ''
//     return function(str: string) {
//         buffer += str
//         const idx = buffer.indexOf(seperator)
//         if (idx === -1) return undefined

//         const message = buffer.slice(idx)
//         buffer = buffer.slice(idx + seperator.length)
//         return message
//     }
// }

// function parse(raw: string) {
//     if (!raw.includes('id:') && !raw.includes('data:')) return undefined
//     const [headers, data] = raw.split('data: ')
//     const meta = headers.split('\n').map((line) => {
//         const [field, value] = line.trim().split(':').map((item) => item.trim())
//         if (value === undefined) return undefined
//         if (field === 'id') return [field, Number(value)]
//         return [field, value]
//     }).filter((item): item is [string, any] => item !== undefined)

//     try {

//         const json = JSON.parse(data.trim())

//         if (Array.isArray(json)) {
//             return Object.fromEntries([...meta, ['type', 'json/array'], ['data', json]])
//         } else {
//             return Object.fromEntries([...meta, ['type', 'json/object'], ['data', json]])
//         }
//     } catch (e) {
//         return Object.fromEntries([...meta, ['data', data.trim()] ])
//     }
// }

// const messages = publish(data)
//     .map((data) => data.trim())
//     .map((data) => parse(data))
//     .filter(Boolean)

// console.log(...messages)

function* publish(str: string) {
  let seperator = '\n\n'
  let buffer = str
  while (buffer && buffer.length) {
    const index = buffer.indexOf(seperator)

    if (index === -1) {
      yield buffer + seperator
      buffer = ''
      break
    }

    const j = index + seperator.length
    const randomSlice = buffer.slice(0, j)
    yield randomSlice
    buffer = buffer.slice(j)
  }
}

function* map<I, O>(source: Generator<I>, transform: Generator<O, void, I>) {
  return yield* source.map((item) => transform.next(item).value)
}

function chunkBy(seperator: string) {
  console.log('creating...')
  let buffer: string = ''
  return function (str: string) {
    buffer += str
    const idx = buffer.indexOf(seperator)
    if (idx === -1) return undefined

    const message = buffer.slice(0, idx)
    buffer = buffer.slice(idx + seperator.length)
    return message
  }
}

function parse(raw: string): StreamEventRaw | undefined {
  if (!raw || raw === '\n\n') return undefined
  if (!raw.includes('id:') && !raw.includes('data:')) return undefined
  const [headers, data] = raw.split('data: ')
  const meta = headers
    .split('\n')
    .map((line) => {
      const [field, value] = line
        .trim()
        .split(':')
        .filter((item) => item !== undefined)
        .map((item) => item?.trim())
      if (value === undefined) return undefined
      if (field === 'id') return [field, Number(value)]
      return [field, value]
    })
    .filter((item): item is [string, any] => item !== undefined)

  try {
    const json = JSON.parse(data?.trim())

    if (Array.isArray(json)) {
      return Object.fromEntries([
        ...meta,
        ['type', 'json/array'],
        ['data', json],
      ]) as StreamEventRaw
    } else {
      return Object.fromEntries([
        ...meta,
        ['type', 'json/object'],
        ['data', json],
      ]) as StreamEventRaw
    }
  } catch (e) {
    return Object.fromEntries([
      ...meta,
      ['data', data.trim()],
    ]) as StreamEventRaw
  }
}

async function* consume(readable: ReadableStream<Uint8Array<ArrayBufferLike>>) {
  const reader = readable.getReader()
  const decoder = new TextDecoder()
  try {
    while (true) {
      const { value, done } = await reader.read()
      if (done) break
      const text = decoder.decode(value, { stream: true })
      if (text) yield text
    }
  } finally {
    reader.releaseLock()
  }
}

async function* stream(url: URL) {
  const resp = await fetch(url)
  const stream = consume(resp.body!)
  const chunks = chunkBy('\n\n')

  for await (const incoming of stream) {
    if (!incoming) continue
    const message = chunks(incoming.trim())
    if (message) yield parse(message)
  }
}

type StreamSubscription = (event: StreamEvent) => Promise<void> | void

type StreamEventRaw = Record<string, any> & {
  type: 'json/object' | 'json/array' | string
  id: number
  data: any
}

class StreamEvent {
  static readonly sharedQueue: StreamEvent[] = []
  public readonly id: number = StreamEvent.sharedQueue.length
  public readonly type: string = 'message'
  public readonly data: any
  public readonly createdAt = new Date()
  constructor(raw: StreamEventRaw) {
    if (raw.id) this.id = raw.id
    if (raw.type) this.type = raw.type
    this.data = raw.data
  }
}

function createEventSource(options: { url: URL }) {
  const subscriptions = new Set<StreamSubscription>()
  const events: StreamEvent[] = []
  const state = { closed: false }

  return {
    subscribe(callback: StreamSubscription) {
      subscriptions.add(callback)
      return () => subscriptions.delete(callback)
    },
    unsubscribe(callback: StreamSubscription) {
      subscriptions.delete(callback)
    },
    getSubscriptions() {
      return subscriptions
    },
    getEvents(): readonly StreamEvent[] {
      return events
    },
    close() {
      subscriptions.clear()
    },
    async fetch() {
      for await (const incoming of stream(options.url)) {
        if (state.closed) break
        if (!incoming) continue
        const event = new StreamEvent(incoming)
        events.push(event)
        subscriptions.forEach((sub) => sub(event))
      }
    },
  }
}

function validObject(obj: object | undefined): obj is object {
  return typeof obj === 'object' && obj !== null
}

function validString(str: string | undefined): str is string {
  return typeof str === 'string' && str.length !== 0
}

function validEvent(raw: StreamEventRaw | undefined): raw is StreamEventRaw {
  return typeof raw === 'object' && Boolean(raw)
}

const chunk = chunkBy('\n\n')

const messages = publish(data)
  .map((item) => chunk(item))
  .filter(validString)
  .map((item) => parse(item))
  .filter(validEvent)
  .map((item) => new StreamEvent(item))

console.log(...messages.take(5))
